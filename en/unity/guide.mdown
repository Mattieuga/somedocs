# Tasks

To build a truly responsive Unity game, you must keep long-running operations off of the main thread, and be careful to avoid blocking anything the main thread might be waiting on. This means you will need to execute various operations in the background. To make this easier, we've added a class called `Task`. A task represents an asynchronous operation. Typically, a `Task` is returned from an asynchronous function and gives the ability to continue processing the result of the task. When a task is returned from a function, it's already begun doing its job. A task is not tied to a particular threading model: it represents the work being done, not where it is executing. Tasks have many advantages over other methods of asynchronous programming such as callbacks and the event model.

*   They consume fewer system resources, since they don't occupy a thread while waiting on other tasks.
*   They are independent of threading model, so you don't have to worry about reaching the maximum number of allowed threads, as can happen with `AsyncTask`.
*   Performing several tasks in a row will not create nested "pyramid" code as you would get when using only callbacks.
*   Tasks are fully composable, allowing you to perform branching, parallelism, and complex error handling, without the spaghetti code of having many named callbacks.

Every asynchronous method in the Parse Unity SDK returns a `Task`.

At the top of any code file where you want to handle asynchronous code yourself, you will find it useful to add the `Tasks` namespace, which adds some useful extension methods to the `Task` class:

```csharp
// Other using statements
using System.Threading.Tasks;
```

## The `ContinueWith` Method

Every `Task` has a method named `ContinueWith` which takes a continuation delegate. You can then inspect the task to check if it was successful and to get its result.

```csharp
obj.SaveAsync().ContinueWith(task =>
{
    if (task.IsCanceled)
    {
        // the save was cancelled.
    }
    else if (task.IsFaulted)
    {
        AggregateException exception = task.Exception;
    }
    else
    {
        // the object was saved successfully.
    }
});
```

## Chaining Tasks Together

Tasks are a little bit magical, in that they let you chain them without nesting. `ContinueWith` returns a `Task<T>` - a Task whose result will be available after the continuation runs. If you return a `Task` from your continuation, the result will be a `Task<Task<T>>`. We provide a helper method called `Unwrap`, which returns a task that will only be complete when the inner task has finished running. This lets you perform multiple actions without incurring the pyramid code you would get with callbacks. So, use `ContinueWith` on its own to do more synchronous work, or `ContinueWith().Unwrap()` to do more asynchronous work.

```csharp
var query = new ParseQuery<ParseObject>("Student")
    .OrderByDescending("gpa");

query.FindAsync().ContinueWith(t =>
{
    var students = t.Result;
    IEnumerator<ParseObject> enumerator = students.GetEnumerator();
    enumerator.MoveNext();
    var student = enumerator.Current;
    student["valedictorian"] = true;
    return student.SaveAsync();
}).Unwrap().ContinueWith(t =>
{
    return query.FindAsync();
}).Unwrap().ContinueWith(t =>
{
    var students = t.Result;
    IEnumerator<ParseObject> enumerator = students.GetEnumerator();
    enumerator.MoveNext();
    enumerator.MoveNext();
    var student = enumerator.Current;
    student["salutatorian"] = true;
    return student.SaveAsync();
}).Unwrap().ContinueWith(t =>
{
    // Everything is done!
});
```

## Creating Tasks

When you're getting started, you can just use the tasks returned from methods like `FindAsync` or `SaveAsync`. However, for more advanced scenarios, you may want to make your own tasks. To do that, you create a `TaskCompletionSource`. This object will let you create a new Task, and control whether it gets marked as finished or cancelled. After you create a `Task`, you'll need to call `SetResult`, `SetError`, or `SetCancelled` to trigger its continuations.

```csharp
public Task<string> SucceedAsync() {
    var successful = new TaskCompletionSource<string>();
    successful.SetResult("The good result.");
    return successful.Task;
}

public Task<string> failAsync() {
    var failed = new TaskCompletionSource<string>();
    failed.SetError(new RuntimeException("An error message."));
    return failed.Task;
}
```

If you know the result of a task at the time it is created, there is a convenience method you can use.

```csharp
Task<string> successful = Task.FromResult("The good result.");
```

## Creating Async Methods

With these tools, it's easy to make your own asynchronous functions that return tasks. For example, you can make a task-based version of `Sleep`.

```csharp
public Task SleepAsync(TimeSpan duration) {
    var tcs = new TaskCompletionSource<int>();
    var timer = new Timer(_ =>
    {
        tcs.SetResult(0);
    });
    timer.Change(duration, Timeout.Infinite);
    return tcs.Task;
}

SleepAsync(TimeSpan.FromSeconds(1)).ContinueWith(task =>
{
    // This ran after 1 second!
});
```

## Tasks in Series

Tasks are convenient when you want to do a series of tasks in a row, each one waiting for the previous to finish. For example, imagine you want to delete all of the comments on your blog.

```csharp
var query = new ParseQuery<ParseObject>("Comments").WhereEqualTo("post", 123);

query.FindAsync().ContinueWith(t =>
{
    // Create a trivial completed task as a base case.
    Task task = Task.ForResult(0);
    foreach (var result in t.Result)
    {
        var toDelete = result;
        // For each item, extend the task with a function to delete the item.
        task = task.ContinueWith(_ =>
        {
            // Return a task that will be marked as completed when the delete is finished.
            return result.DeleteAsync();
        }).Unwrap();
      });
    }
    return task;
  }
}).Unwrap().ContinueWith(_ =>
{
    // Every comment was deleted.
});
```

## Tasks in Parallel

You can also perform several tasks in parallel, using the `WhenAll` method. You can start multiple operations at once, and use `Task.WhenAll` to create a new task that will be marked as completed when all of its input tasks are completed. Performing operations in parallel will be faster than doing them serially, but may consume more system resources and bandwidth.

```csharp
var query = new ParseQuery<ParseObject>("Comments").WhereEqualTo("post", 123);

query.FindAsync().ContinueWith(t =>
{
    // Collect one task for each delete into a list
    var tasks = new List<Task>();
    Task task = Task.ForResult(0);
    foreach (var result in t.Result)
    {
        // Start this delete immediately and add its task to the list.
        tasks.Add(result.DeleteAsync());
    }
    // Return a new task that will be marked as completed when all of the deletes are
    // finished.
    return Task.WhenAll(tasks);
  }
}).Unwrap().ContinueWith(_ =>
{
    // Every comment was deleted.
});
```

## Tasks and Coroutines

Unity provides the notion of a Coroutine for cooperative multitasking, allowing code to be interleaved while all running on the main thread.  Tasks and the continuation model are mostly independent of this multitasking mechanism, but are easy to adapt to work within a coroutine. Your coroutine can simply check the `IsCompleted` property of a task to know whether the asynchronous work has completed, allowing the coroutine to continue where it left off.  For example, the following coroutine code saves an object and then waits for a query to return:

```csharp
public IEnumerator GameOver()
{
    var gameHistory = new ParseObject("GameHistory");
    gameHistory["score"] = score;
    gameHistory["player"] = ParseUser.CurrentUser;

    var saveTask = gameHistory.SaveAsync();
    while (!saveTask.IsCompleted) yield return null;

    // When the coroutine reaches this point, the save will be complete

    var historyQuery = new ParseQuery<ParseObject>("GameHistory")
        .WhereEqualTo("player", ParseUser.CurrentUser)
        .OrderByDescending("createdAt");

    var queryTask = historyQuery.FindAsync();
    while (!queryTask.IsCompleted) yield return null;

    // The task is complete, so we can simply check for its result to get
    // the current player's game history
    var history = queryTask.Result;
}
```

